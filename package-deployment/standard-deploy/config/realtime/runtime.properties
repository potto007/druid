druid.service=realtime

#default
#druid.indexer.task.baseDir=/tmp
#default
#druid.indexer.task.baseTaskDir=/tmp/persistent/tasks
#default
druid.indexer.task.defaultRowFlushBoundary=50000
#Needed for tranquilty to find the indexer in order to push data to it?
druid.indexer.task.chathandler.type=announce 

# Remote peon options (defaults)
druid.peon.taskActionClient.retry.minWait=PT1M
druid.peon.taskActionClient.retry.maxWait=PT10M
druid.peon.taskActionClient.retry.maxRetryCount=10
# See http://druid.io/docs/latest/Peons.html
# If don't set this to local, then the peon uses the druid.selectors.indexing.serviceName property to try to discover the overlord-- which we don't have.
# See http://druid.io/docs/latest/Configuration.html
#druid.peon.mode=local


# Peon properties
druid.monitoring.monitors=["com.metamx.metrics.JvmMonitor"]
 #recommended by Metamx prod
druid.processing.buffer.sizeBytes=536870912
druid.processing.numThreads=8

# While we could set this here, it is desirable to use some math based on the number of brokers in launch scripts (e.g. numThreads=numBrokers*druid.broker.http.numConnections)
# So push these settings into the launch scripts.
# From Hagen Rother:
# The sum of all druid.broker.http.numConnections must be smaller than each druid.server.http.numThreads (i.e. check each historical and realtime)
# (If the number of threads is larger, one can end up with a deadlock situation distributing the queries to the realtime/historical query nodes.)
#druid.server.http.numThreads=100

